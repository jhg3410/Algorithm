## 작업 스케줄링

### 작업,작업의 수행시간, 기계가 주어질 때 모든 작업이 가장 빨리 종료되도록 기계에 작업을 배정하는 알고리즘입니다.
코드는 다음과 같다.


```python

def solve(n,m,t):
    L = []      # 리스트 생성
    for j in range(m):
        L.append(0)     # 리스트에 0으로 초기화
    for i in range(n):
        min = 0     # 비교값 지정
        for j in range(m):
            if L[j] < L[min]:    # m(기계 수)인덱스의 L값과 비교값과 비교후 L[j]가 더 작으면
                min = j     # min값 새로고침
        L[min] += t[i]      # L에 가장 작은 값에 t의 각 요소를 추가
    return max(L)        # for문이 다 돈 후 마무리된 L의 최대값 반환

```

main(입출력)은 교체하면서 진행 할 예정이라 해결 함수만 보겠습니다.  
먼저 기계에 작업(수행시간)을 배정할 리스트를 생성하고 기계의 수 만큼 리스트를 0으로 초기화 시켜줍니다.  
그러고는 작업의 수만큼 min(비교,최솟값)을 0으로 초기화하고 다시 m만틈 돌면서
각 리스트의 요소를 하나씩 비교하면서 가장작은 index를 찾아 min값을 새로고침해준다.  
그러면 L[min]은 리스트에서 가장 최솟값이 된다. 거기에 t의 각 요소를 추가해주면서 작업을 n(작업의 수)만큼 for 문을 돌려주면 마무리된 L이 나온다.  
마지막으로 L에서 가장 높은값(작업시간이 가장 긴 기계)를 반환 시켜준다.  

이 알고리즘에서 구하는 값은 근사값이다. 코드안에 보다시피 t의 인덱스 순서로 추가하기때문에 정렬을 하지않고 순서대로 넣다보니 최적해가아닌 근사해가 나온다.  
하지만 이 알고리즘으로 t를 랜덤으로 두고 코드를 실행하면 사실 별 차이가없다. 그만큼 근사해가 최적해와 차이가 크지 않다고 보면된다.  
교수님의 ppt에도 있듯이 근사해를 OPT'라 하고, 최적해를 OPT라고 할 때, OPT' ≤ 2xOPT 이다. 2배를 넘어가지않는다는 말이다.

``` python
n = 2**8   # 작업 수
m = 16     # 기계 수
t = []
for i in range(n):
    t.append(random.randrange(1,30))    # 각 작업의 소요시간

print(solve(n,m,t))
```
위의 함수에 위 코드로 실행하면
![image](https://user-images.githubusercontent.com/80373033/118241523-3714a400-b4d7-11eb-9270-de63322f5ddc.png)  
위 설명처럼 랜덤으로 t를 넣어도 별 차이가 안나는것을 볼 수 있다.
