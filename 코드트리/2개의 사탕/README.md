걸린 시간: 2시간 40분

골1

[코드트리 | 코딩테스트 준비를 위한 알고리즘 정석](https://www.codetree.ai/training-field/frequent-problems/problems/two-candies/description?page=13&pageSize=5)

시간 복잡도를 고려가 필요한 백트래킹 + 시뮬레이션

아쉬웠던 점

- 시간 초과,,,
    - 10번의 방향을 모두 각각 회전 시키며, 방향으로 이동시키는 로직 - 시간 초과
    - 이전 방향으로 이동시킨 정보를 지속한 채 이어서 진행하는 로직 - 통과

왼쪽, 오른쪽, 위쪽

이런식으로 진행될 때, 기존엔

1. 왼
2. 왼 → 오른
3. 왼 → 오른 → 위

변경 후

1. 왼
2. 1 이후의 정보를 가진채 오른
3. 2 이후의 정보를 가진 채 위

해설

1. 굳이 회전을 시키고, 아래로 고정시킬 필요가 없었다.
    1. 이렇게 했던 이유가 예외처리가 너무 복잡할 것 같았다
    2. 사탕을 택하는 순서에 따라  또 케이스가 달라지기에
    3. 그런데 왼쪽, 위로 사탕이 흐른다면, 왼쪽상단부터, 오른쪽 하단까지 탐색하면서 걸리는 사탕부터 처리하면 된다.
    4. 반대로 오른쪽, 아래로 흐른다면, 우측 하단부터, 좌측 상단까지 탐색하면서 걸리는 사탕부터 처리
2. 격자판은 놔두고 사탕의 위치만 변경하는 로직
    1. 이러면 격자판을 탐색할 필요가 없고, 사탕의 위치만 백트래킹마다 옮겨주면 됨
        1. → `O(4^R(10) * max(n,m))`
    2. 사탕의 우선순위도 정해야함
        1. 각 방향마다 특정 조건에 의해, 빨간색이 먼저 움직일지 파란색이 먼저 움직일지를 판단해야함
    3. 메모제이션
        1. `빨간 사탕, 파란 사탕, 방향 횟수` 이렇게 3개가 동일하다면 한 번만 탐색하면 된다.
            1. `visited` 느낌
    4. `bfs` 로도 풀 수 있다.
        1. 처음 빨간 사탕, 파란 사탕 좌표를 시작으로 각 방향으로 이동한 후의 좌표를 계속 queue 에 넣어주는 방식
        2. 만약 둘 중 하나의 사탕이 exit 로 통과했다면 continue 처리
        3. 다 끝내면 이제 빨간 사탕만 exit, 파란 사탕은 아직 맵에 있으면서 step(이동한 횟수)의 최솟값을 구하면 된다.