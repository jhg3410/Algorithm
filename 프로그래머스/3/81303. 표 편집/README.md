## 표 편집

`걸린 시간: 2시간 반 (풀이 참고)`

LEVEL 3

[표 편집](https://school.programmers.co.kr/learn/courses/30/lessons/81303)

- 아쉬운 점
    - 시간복잡도를 고려하고 풀었음에도, 만족하지 못함
    - 아래의 지문을 읽지 못하고, 접근..
    
    > `cmd`에 등장하는 모든 X들의 값을 합친 결과가 1,000,000 이하인 경우만 입력으로 주어집니다.
    > 

- 풀이 보기 전
    - `cmd` 의 X 는 100만이 넘지 않으니, down, up은 딱히 시간을 고려하지 않았다.
    - 행 삭제 유무를 가지는 최대 100만 크기의 Boolean List 로 접근
    - 하지만 삭제할 때, 이전 또는 이후의 삭제되지 않은 행을 찾는 게 최대 `O(n)` 소모
    - 그래서 효율성에서 실패

<br/>

풀이를 보고

### 더블 링크드 리스트 개념으로 접근

- 행들이 서로의 앞 뒤를 알면 순차탐색을 할 필요가 없이 바로 접근이 가능 `O(n)`
- 그래서 아래처럼 키값엔 본인 행 번호, 밸류 값엔 앞 또는 뒤를 가지고 있는 dict 로 접근해서 해결

```python
fronts = dict()
backs = dict()
```

- 코드트리에서도 유사한 문제가 있었고 풀었던 경험이 있는디 아쉽구만
- 이차원 배열로 푸신분도 존재
- 아래처럼 해서 각 행엔 번호, `0열`엔 앞, `1열`엔 뒤의 행 번호가 들어가도록해서 해결

```python
for i in range(n):
  sheet.append([i - 1, i + 1])
```

### 우선 순위 큐로 접근

- 풀이 중 우선순위큐로 해결한 풀이가 있었다.(번호순으로 항상 정렬이 되어 있기에 가능)

```python
max_heap = list(map(inverse,range(k)))
min_heap = list(range(k,n))
```

이렇게 현재 선택된 행 번호 기준으로 왼쪽, 오른쪽을 나눈다.

이렇게 했을 때

제거한다면?

- `min_heap` 에서 heappop 하면 된다.
- 그럼 자동으로 `min_heap` 엔 다음 행이 최우선순위이다.(번호순이기에)

복구한다면?

- 가장 최근에 제거한 번호를 빼내서, `min_heap` 의 최우선순위 행번호보다 낮다면 당연히 왼쪽인 max_heap 에 넣는다.
- 크다면 왼쪽인 `min_heap` 에

이동할 땐?

- max_heap 의 일부를 min_heap 으로 옮기면?
- min_heap 은 늘어나고 자연스럽 선택 행 번호가 작아진다.`(UP)`
- 반대도 동일
